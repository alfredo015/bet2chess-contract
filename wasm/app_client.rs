// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct AppFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> AppFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::AppFactory for AppFactory<R> {
    type Args = R::Args;
    fn new(&self) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, app_factory::io::New>::new(self.remoting.clone(), ())
    }
}

pub mod app_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <New as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = ();
            type Reply = ();
        }
    }
}
pub struct Bet2Chess<R> {
    remoting: R,
}
impl<R> Bet2Chess<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Bet2Chess for Bet2Chess<R> {
    type Args = R::Args;
    fn accept_invitation(
        &mut self,
        web2_user_id: u64,
        web2_user_id_invitation_owner: u64,
        web2_match_game_id: u64,
        username_from_user_who_invite: String,
        own_username: String,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::AcceptInvitation>::new(
            self.remoting.clone(),
            (
                web2_user_id,
                web2_user_id_invitation_owner,
                web2_match_game_id,
                username_from_user_who_invite,
                own_username,
            ),
        )
    }
    fn accept_invitation_signless(
        &mut self,
        user_address: ActorId,
        web2_user_id: u64,
        web2_user_id_invitation_owner: u64,
        web2_match_game_id: u64,
        username_from_user_who_invite: String,
        own_username: String,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::AcceptInvitationSignless>::new(
            self.remoting.clone(),
            (
                user_address,
                web2_user_id,
                web2_user_id_invitation_owner,
                web2_match_game_id,
                username_from_user_who_invite,
                own_username,
            ),
        )
    }
    fn accept_invitation_signless_no_wallet(
        &mut self,
        no_wallet_name_encoded: String,
        web2_user_id: u64,
        web2_user_id_invitation_owner: u64,
        web2_match_game_id: u64,
        username_from_user_who_invite: String,
        own_username: String,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::AcceptInvitationSignlessNoWallet>::new(
            self.remoting.clone(),
            (
                no_wallet_name_encoded,
                web2_user_id,
                web2_user_id_invitation_owner,
                web2_match_game_id,
                username_from_user_who_invite,
                own_username,
            ),
        )
    }
    fn cancel_invitation(
        &mut self,
        first_web2_id: u64,
        second_web2_id: u64,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::CancelInvitation>::new(
            self.remoting.clone(),
            (first_web2_id, second_web2_id),
        )
    }
    fn cancel_invitation_signless(
        &mut self,
        user_address: ActorId,
        first_web2_id: u64,
        second_web2_id: u64,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::CancelInvitationSignless>::new(
            self.remoting.clone(),
            (user_address, first_web2_id, second_web2_id),
        )
    }
    fn cancel_invitation_signless_no_wallet(
        &mut self,
        no_wallet_name_encoded: String,
        first_web2_id: u64,
        second_web2_id: u64,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::CancelInvitationSignlessNoWallet>::new(
            self.remoting.clone(),
            (no_wallet_name_encoded, first_web2_id, second_web2_id),
        )
    }
    fn end_game_by_id(
        &mut self,
        game_id: u64,
        game_winner: Option<ActorId>,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::EndGameById>::new(
            self.remoting.clone(),
            (game_id, game_winner),
        )
    }
    fn end_match(
        &mut self,
        game_id: u64,
        game_winner: Option<ActorId>,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::EndMatch>::new(
            self.remoting.clone(),
            (game_id, game_winner),
        )
    }
    fn send_invitation(
        &mut self,
        web2_user_id: u64,
        web2_guest_id: u64,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::SendInvitation>::new(
            self.remoting.clone(),
            (web2_user_id, web2_guest_id),
        )
    }
    fn send_invitation_signless(
        &mut self,
        user_address: ActorId,
        web2_user_id: u64,
        web2_guest_id: u64,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::SendInvitationSignless>::new(
            self.remoting.clone(),
            (user_address, web2_user_id, web2_guest_id),
        )
    }
    fn send_invitation_signless_no_wallet(
        &mut self,
        no_wallet_name_encoded: String,
        web2_user_id: u64,
        web2_guest_id: u64,
    ) -> impl Call<Output = Bet2ChessEvents, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::SendInvitationSignlessNoWallet>::new(
            self.remoting.clone(),
            (no_wallet_name_encoded, web2_user_id, web2_guest_id),
        )
    }
    fn all_games(&self) -> impl Query<Output = Vec<(u64, GameData)>, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::AllGames>::new(self.remoting.clone(), ())
    }
    fn game_data(&self, game_id: u64) -> impl Query<Output = Option<GameData>, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::GameData>::new(self.remoting.clone(), game_id)
    }
    fn games_id_ended(&self) -> impl Query<Output = Vec<u64>, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::GamesIdEnded>::new(self.remoting.clone(), ())
    }
    fn games_id_started(&self) -> impl Query<Output = Vec<u64>, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::GamesIdStarted>::new(self.remoting.clone(), ())
    }
    fn games_id_waiting(&self) -> impl Query<Output = Vec<u64>, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::GamesIdWaiting>::new(self.remoting.clone(), ())
    }
    fn invitation_bet(
        &self,
        first_web2_id: u64,
        second_web2_id: u64,
    ) -> impl Query<Output = Option<u128>, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::InvitationBet>::new(
            self.remoting.clone(),
            (first_web2_id, second_web2_id),
        )
    }
    fn invitations_from_web_2_id(
        &self,
        web2_id: u64,
    ) -> impl Query<Output = Option<InvitationsState>, Args = R::Args> {
        RemotingAction::<_, bet_2_chess::io::InvitationsFromWeb2Id>::new(
            self.remoting.clone(),
            web2_id,
        )
    }
}

pub mod bet_2_chess {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AcceptInvitation(());
        impl AcceptInvitation {
            #[allow(dead_code)]
            pub fn encode_call(
                web2_user_id: u64,
                web2_user_id_invitation_owner: u64,
                web2_match_game_id: u64,
                username_from_user_who_invite: String,
                own_username: String,
            ) -> Vec<u8> {
                <AcceptInvitation as ActionIo>::encode_call(&(
                    web2_user_id,
                    web2_user_id_invitation_owner,
                    web2_match_game_id,
                    username_from_user_who_invite,
                    own_username,
                ))
            }
        }
        impl ActionIo for AcceptInvitation {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 64, 65, 99, 99, 101, 112, 116, 73,
                110, 118, 105, 116, 97, 116, 105, 111, 110,
            ];
            type Params = (u64, u64, u64, String, String);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct AcceptInvitationSignless(());
        impl AcceptInvitationSignless {
            #[allow(dead_code)]
            pub fn encode_call(
                user_address: ActorId,
                web2_user_id: u64,
                web2_user_id_invitation_owner: u64,
                web2_match_game_id: u64,
                username_from_user_who_invite: String,
                own_username: String,
            ) -> Vec<u8> {
                <AcceptInvitationSignless as ActionIo>::encode_call(&(
                    user_address,
                    web2_user_id,
                    web2_user_id_invitation_owner,
                    web2_match_game_id,
                    username_from_user_who_invite,
                    own_username,
                ))
            }
        }
        impl ActionIo for AcceptInvitationSignless {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 96, 65, 99, 99, 101, 112, 116, 73,
                110, 118, 105, 116, 97, 116, 105, 111, 110, 83, 105, 103, 110, 108, 101, 115, 115,
            ];
            type Params = (ActorId, u64, u64, u64, String, String);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct AcceptInvitationSignlessNoWallet(());
        impl AcceptInvitationSignlessNoWallet {
            #[allow(dead_code)]
            pub fn encode_call(
                no_wallet_name_encoded: String,
                web2_user_id: u64,
                web2_user_id_invitation_owner: u64,
                web2_match_game_id: u64,
                username_from_user_who_invite: String,
                own_username: String,
            ) -> Vec<u8> {
                <AcceptInvitationSignlessNoWallet as ActionIo>::encode_call(&(
                    no_wallet_name_encoded,
                    web2_user_id,
                    web2_user_id_invitation_owner,
                    web2_match_game_id,
                    username_from_user_who_invite,
                    own_username,
                ))
            }
        }
        impl ActionIo for AcceptInvitationSignlessNoWallet {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 128, 65, 99, 99, 101, 112, 116, 73,
                110, 118, 105, 116, 97, 116, 105, 111, 110, 83, 105, 103, 110, 108, 101, 115, 115,
                78, 111, 87, 97, 108, 108, 101, 116,
            ];
            type Params = (String, u64, u64, u64, String, String);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct CancelInvitation(());
        impl CancelInvitation {
            #[allow(dead_code)]
            pub fn encode_call(first_web2_id: u64, second_web2_id: u64) -> Vec<u8> {
                <CancelInvitation as ActionIo>::encode_call(&(first_web2_id, second_web2_id))
            }
        }
        impl ActionIo for CancelInvitation {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 64, 67, 97, 110, 99, 101, 108, 73,
                110, 118, 105, 116, 97, 116, 105, 111, 110,
            ];
            type Params = (u64, u64);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct CancelInvitationSignless(());
        impl CancelInvitationSignless {
            #[allow(dead_code)]
            pub fn encode_call(
                user_address: ActorId,
                first_web2_id: u64,
                second_web2_id: u64,
            ) -> Vec<u8> {
                <CancelInvitationSignless as ActionIo>::encode_call(&(
                    user_address,
                    first_web2_id,
                    second_web2_id,
                ))
            }
        }
        impl ActionIo for CancelInvitationSignless {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 96, 67, 97, 110, 99, 101, 108, 73,
                110, 118, 105, 116, 97, 116, 105, 111, 110, 83, 105, 103, 110, 108, 101, 115, 115,
            ];
            type Params = (ActorId, u64, u64);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct CancelInvitationSignlessNoWallet(());
        impl CancelInvitationSignlessNoWallet {
            #[allow(dead_code)]
            pub fn encode_call(
                no_wallet_name_encoded: String,
                first_web2_id: u64,
                second_web2_id: u64,
            ) -> Vec<u8> {
                <CancelInvitationSignlessNoWallet as ActionIo>::encode_call(&(
                    no_wallet_name_encoded,
                    first_web2_id,
                    second_web2_id,
                ))
            }
        }
        impl ActionIo for CancelInvitationSignlessNoWallet {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 128, 67, 97, 110, 99, 101, 108, 73,
                110, 118, 105, 116, 97, 116, 105, 111, 110, 83, 105, 103, 110, 108, 101, 115, 115,
                78, 111, 87, 97, 108, 108, 101, 116,
            ];
            type Params = (String, u64, u64);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct EndGameById(());
        impl EndGameById {
            #[allow(dead_code)]
            pub fn encode_call(game_id: u64, game_winner: Option<ActorId>) -> Vec<u8> {
                <EndGameById as ActionIo>::encode_call(&(game_id, game_winner))
            }
        }
        impl ActionIo for EndGameById {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 44, 69, 110, 100, 71, 97, 109, 101,
                66, 121, 73, 100,
            ];
            type Params = (u64, Option<ActorId>);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct EndMatch(());
        impl EndMatch {
            #[allow(dead_code)]
            pub fn encode_call(game_id: u64, game_winner: Option<ActorId>) -> Vec<u8> {
                <EndMatch as ActionIo>::encode_call(&(game_id, game_winner))
            }
        }
        impl ActionIo for EndMatch {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 32, 69, 110, 100, 77, 97, 116, 99,
                104,
            ];
            type Params = (u64, Option<ActorId>);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct SendInvitation(());
        impl SendInvitation {
            #[allow(dead_code)]
            pub fn encode_call(web2_user_id: u64, web2_guest_id: u64) -> Vec<u8> {
                <SendInvitation as ActionIo>::encode_call(&(web2_user_id, web2_guest_id))
            }
        }
        impl ActionIo for SendInvitation {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 56, 83, 101, 110, 100, 73, 110, 118,
                105, 116, 97, 116, 105, 111, 110,
            ];
            type Params = (u64, u64);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct SendInvitationSignless(());
        impl SendInvitationSignless {
            #[allow(dead_code)]
            pub fn encode_call(
                user_address: ActorId,
                web2_user_id: u64,
                web2_guest_id: u64,
            ) -> Vec<u8> {
                <SendInvitationSignless as ActionIo>::encode_call(&(
                    user_address,
                    web2_user_id,
                    web2_guest_id,
                ))
            }
        }
        impl ActionIo for SendInvitationSignless {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 88, 83, 101, 110, 100, 73, 110, 118,
                105, 116, 97, 116, 105, 111, 110, 83, 105, 103, 110, 108, 101, 115, 115,
            ];
            type Params = (ActorId, u64, u64);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct SendInvitationSignlessNoWallet(());
        impl SendInvitationSignlessNoWallet {
            #[allow(dead_code)]
            pub fn encode_call(
                no_wallet_name_encoded: String,
                web2_user_id: u64,
                web2_guest_id: u64,
            ) -> Vec<u8> {
                <SendInvitationSignlessNoWallet as ActionIo>::encode_call(&(
                    no_wallet_name_encoded,
                    web2_user_id,
                    web2_guest_id,
                ))
            }
        }
        impl ActionIo for SendInvitationSignlessNoWallet {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 120, 83, 101, 110, 100, 73, 110, 118,
                105, 116, 97, 116, 105, 111, 110, 83, 105, 103, 110, 108, 101, 115, 115, 78, 111,
                87, 97, 108, 108, 101, 116,
            ];
            type Params = (String, u64, u64);
            type Reply = super::Bet2ChessEvents;
        }
        pub struct AllGames(());
        impl AllGames {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <AllGames as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for AllGames {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 32, 65, 108, 108, 71, 97, 109, 101,
                115,
            ];
            type Params = ();
            type Reply = Vec<(u64, super::GameData)>;
        }
        pub struct GameData(());
        impl GameData {
            #[allow(dead_code)]
            pub fn encode_call(game_id: u64) -> Vec<u8> {
                <GameData as ActionIo>::encode_call(&game_id)
            }
        }
        impl ActionIo for GameData {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 32, 71, 97, 109, 101, 68, 97, 116, 97,
            ];
            type Params = u64;
            type Reply = Option<super::GameData>;
        }
        pub struct GamesIdEnded(());
        impl GamesIdEnded {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GamesIdEnded as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GamesIdEnded {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 48, 71, 97, 109, 101, 115, 73, 100,
                69, 110, 100, 101, 100,
            ];
            type Params = ();
            type Reply = Vec<u64>;
        }
        pub struct GamesIdStarted(());
        impl GamesIdStarted {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GamesIdStarted as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GamesIdStarted {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 56, 71, 97, 109, 101, 115, 73, 100,
                83, 116, 97, 114, 116, 101, 100,
            ];
            type Params = ();
            type Reply = Vec<u64>;
        }
        pub struct GamesIdWaiting(());
        impl GamesIdWaiting {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <GamesIdWaiting as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for GamesIdWaiting {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 56, 71, 97, 109, 101, 115, 73, 100,
                87, 97, 105, 116, 105, 110, 103,
            ];
            type Params = ();
            type Reply = Vec<u64>;
        }
        pub struct InvitationBet(());
        impl InvitationBet {
            #[allow(dead_code)]
            pub fn encode_call(first_web2_id: u64, second_web2_id: u64) -> Vec<u8> {
                <InvitationBet as ActionIo>::encode_call(&(first_web2_id, second_web2_id))
            }
        }
        impl ActionIo for InvitationBet {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 52, 73, 110, 118, 105, 116, 97, 116,
                105, 111, 110, 66, 101, 116,
            ];
            type Params = (u64, u64);
            type Reply = Option<u128>;
        }
        pub struct InvitationsFromWeb2Id(());
        impl InvitationsFromWeb2Id {
            #[allow(dead_code)]
            pub fn encode_call(web2_id: u64) -> Vec<u8> {
                <InvitationsFromWeb2Id as ActionIo>::encode_call(&web2_id)
            }
        }
        impl ActionIo for InvitationsFromWeb2Id {
            const ROUTE: &'static [u8] = &[
                36, 66, 101, 116, 50, 67, 104, 101, 115, 115, 84, 73, 110, 118, 105, 116, 97, 116,
                105, 111, 110, 115, 70, 114, 111, 109, 87, 101, 98, 50, 73, 100,
            ];
            type Params = u64;
            type Reply = Option<super::InvitationsState>;
        }
    }
}
pub struct QueryService<R> {
    remoting: R,
}
impl<R> QueryService<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::QueryService for QueryService<R> {
    type Args = R::Args;
    fn signless_account_data(
        &self,
        signless_address: ActorId,
    ) -> impl Query<Output = QueryEvent, Args = R::Args> {
        RemotingAction::<_, query_service::io::SignlessAccountData>::new(
            self.remoting.clone(),
            signless_address,
        )
    }
    fn signless_address_from_no_wallet_account(
        &self,
        no_wallet_account: String,
    ) -> impl Query<Output = QueryEvent, Args = R::Args> {
        RemotingAction::<_, query_service::io::SignlessAddressFromNoWalletAccount>::new(
            self.remoting.clone(),
            no_wallet_account,
        )
    }
    fn signless_address_from_user_address(
        &self,
        user_address: ActorId,
    ) -> impl Query<Output = QueryEvent, Args = R::Args> {
        RemotingAction::<_, query_service::io::SignlessAddressFromUserAddress>::new(
            self.remoting.clone(),
            user_address,
        )
    }
}

pub mod query_service {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct SignlessAccountData(());
        impl SignlessAccountData {
            #[allow(dead_code)]
            pub fn encode_call(signless_address: ActorId) -> Vec<u8> {
                <SignlessAccountData as ActionIo>::encode_call(&signless_address)
            }
        }
        impl ActionIo for SignlessAccountData {
            const ROUTE: &'static [u8] = &[
                48, 81, 117, 101, 114, 121, 83, 101, 114, 118, 105, 99, 101, 76, 83, 105, 103, 110,
                108, 101, 115, 115, 65, 99, 99, 111, 117, 110, 116, 68, 97, 116, 97,
            ];
            type Params = ActorId;
            type Reply = super::QueryEvent;
        }
        pub struct SignlessAddressFromNoWalletAccount(());
        impl SignlessAddressFromNoWalletAccount {
            #[allow(dead_code)]
            pub fn encode_call(no_wallet_account: String) -> Vec<u8> {
                <SignlessAddressFromNoWalletAccount as ActionIo>::encode_call(&no_wallet_account)
            }
        }
        impl ActionIo for SignlessAddressFromNoWalletAccount {
            const ROUTE: &'static [u8] = &[
                48, 81, 117, 101, 114, 121, 83, 101, 114, 118, 105, 99, 101, 136, 83, 105, 103,
                110, 108, 101, 115, 115, 65, 100, 100, 114, 101, 115, 115, 70, 114, 111, 109, 78,
                111, 87, 97, 108, 108, 101, 116, 65, 99, 99, 111, 117, 110, 116,
            ];
            type Params = String;
            type Reply = super::QueryEvent;
        }
        pub struct SignlessAddressFromUserAddress(());
        impl SignlessAddressFromUserAddress {
            #[allow(dead_code)]
            pub fn encode_call(user_address: ActorId) -> Vec<u8> {
                <SignlessAddressFromUserAddress as ActionIo>::encode_call(&user_address)
            }
        }
        impl ActionIo for SignlessAddressFromUserAddress {
            const ROUTE: &'static [u8] = &[
                48, 81, 117, 101, 114, 121, 83, 101, 114, 118, 105, 99, 101, 120, 83, 105, 103,
                110, 108, 101, 115, 115, 65, 100, 100, 114, 101, 115, 115, 70, 114, 111, 109, 85,
                115, 101, 114, 65, 100, 100, 114, 101, 115, 115,
            ];
            type Params = ActorId;
            type Reply = super::QueryEvent;
        }
    }
}
pub struct Signless<R> {
    remoting: R,
}
impl<R> Signless<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Signless for Signless<R> {
    type Args = R::Args;
    fn bind_signless_data_to_address(
        &mut self,
        user_address: ActorId,
        signless_data: SignlessAccount,
    ) -> impl Call<Output = SignlessEvent, Args = R::Args> {
        RemotingAction::<_, signless::io::BindSignlessDataToAddress>::new(
            self.remoting.clone(),
            (user_address, signless_data),
        )
    }
    fn bind_signless_data_to_no_wallet_account(
        &mut self,
        no_wallet_account: String,
        signless_data: SignlessAccount,
    ) -> impl Call<Output = SignlessEvent, Args = R::Args> {
        RemotingAction::<_, signless::io::BindSignlessDataToNoWalletAccount>::new(
            self.remoting.clone(),
            (no_wallet_account, signless_data),
        )
    }
}

pub mod signless {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct BindSignlessDataToAddress(());
        impl BindSignlessDataToAddress {
            #[allow(dead_code)]
            pub fn encode_call(
                user_address: ActorId,
                signless_data: super::SignlessAccount,
            ) -> Vec<u8> {
                <BindSignlessDataToAddress as ActionIo>::encode_call(&(user_address, signless_data))
            }
        }
        impl ActionIo for BindSignlessDataToAddress {
            const ROUTE: &'static [u8] = &[
                32, 83, 105, 103, 110, 108, 101, 115, 115, 100, 66, 105, 110, 100, 83, 105, 103,
                110, 108, 101, 115, 115, 68, 97, 116, 97, 84, 111, 65, 100, 100, 114, 101, 115,
                115,
            ];
            type Params = (ActorId, super::SignlessAccount);
            type Reply = super::SignlessEvent;
        }
        pub struct BindSignlessDataToNoWalletAccount(());
        impl BindSignlessDataToNoWalletAccount {
            #[allow(dead_code)]
            pub fn encode_call(
                no_wallet_account: String,
                signless_data: super::SignlessAccount,
            ) -> Vec<u8> {
                <BindSignlessDataToNoWalletAccount as ActionIo>::encode_call(&(
                    no_wallet_account,
                    signless_data,
                ))
            }
        }
        impl ActionIo for BindSignlessDataToNoWalletAccount {
            const ROUTE: &'static [u8] = &[
                32, 83, 105, 103, 110, 108, 101, 115, 115, 132, 66, 105, 110, 100, 83, 105, 103,
                110, 108, 101, 115, 115, 68, 97, 116, 97, 84, 111, 78, 111, 87, 97, 108, 108, 101,
                116, 65, 99, 99, 111, 117, 110, 116,
            ];
            type Params = (String, super::SignlessAccount);
            type Reply = super::SignlessEvent;
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Bet2ChessEvents {
    PlayingInMatch(u64),
    SignlessError(SignlessError),
    Error(Bet2ChessErrors),
    GameCreated(u64),
    JoinedInGame(u64),
    GameEnded(u64),
    InvitationSentTo(u64),
    InvitationCancelled,
    Price,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum SignlessError {
    SignlessAccountHasInvalidSession,
    SignlessAccountNotApproved,
    SignlessAddressAlreadyEsists,
    UserAddressAlreadyExists,
    UserDoesNotHasSignlessAccount,
    NoWalletAccountAlreadyExists,
    NoWalletAccountDoesNotHasSignlessAccount,
    SessionHasInvalidSignlessAccount,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum Bet2ChessErrors {
    GameIdDoesNotExists(u64),
    GameWithIdAlreadyStarts(u64),
    GameAlreadyStart(u64),
    BetIsNotTheSameForMatch { game_bet: u128, bet_by_user: u128 },
    UserAlreadyInviteThePlayer(u64),
    UserHasNoInvitationfromTheUser(u64),
    UserAddressAndWeb2IdAreNotRelated,
    CantIncrementGamesIdItOverflow,
    InvitationDoesNotExists,
    ThereAreNoGamesWaiting,
    MinAmoutToBetIsOneToken,
    OnlyAdminsCanEndGames,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct GameData {
    pub game_bet: u128,
    pub player1: ActorId,
    pub player2: ActorId,
    pub player1_username: String,
    pub player2_username: String,
    pub player1_web2_id: u64,
    pub player2_web2_id: u64,
    pub winner: Option<ActorId>,
    pub status: GameStatus,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum GameStatus {
    Waiting,
    Started,
    Ended { winner: Option<ActorId> },
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct InvitationsState {
    pub received_invitations_from_users: Vec<u64>,
    pub sent_invitations_to_users: Vec<u64>,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum QueryEvent {
    GameData(GameData),
    SignlessAccountAddress(Option<ActorId>),
    SignlessAccountData(Option<SignlessAccount>),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SignlessAccount {
    pub address: String,
    pub encoded: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum SignlessEvent {
    SignlessAccountSet,
    Error(SignlessError),
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait AppFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Bet2Chess {
        type Args;
        fn accept_invitation(
            &mut self,
            web2_user_id: u64,
            web2_user_id_invitation_owner: u64,
            web2_match_game_id: u64,
            username_from_user_who_invite: String,
            own_username: String,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn accept_invitation_signless(
            &mut self,
            user_address: ActorId,
            web2_user_id: u64,
            web2_user_id_invitation_owner: u64,
            web2_match_game_id: u64,
            username_from_user_who_invite: String,
            own_username: String,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn accept_invitation_signless_no_wallet(
            &mut self,
            no_wallet_name_encoded: String,
            web2_user_id: u64,
            web2_user_id_invitation_owner: u64,
            web2_match_game_id: u64,
            username_from_user_who_invite: String,
            own_username: String,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn cancel_invitation(
            &mut self,
            first_web2_id: u64,
            second_web2_id: u64,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn cancel_invitation_signless(
            &mut self,
            user_address: ActorId,
            first_web2_id: u64,
            second_web2_id: u64,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn cancel_invitation_signless_no_wallet(
            &mut self,
            no_wallet_name_encoded: String,
            first_web2_id: u64,
            second_web2_id: u64,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn end_game_by_id(
            &mut self,
            game_id: u64,
            game_winner: Option<ActorId>,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn end_match(
            &mut self,
            game_id: u64,
            game_winner: Option<ActorId>,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn send_invitation(
            &mut self,
            web2_user_id: u64,
            web2_guest_id: u64,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn send_invitation_signless(
            &mut self,
            user_address: ActorId,
            web2_user_id: u64,
            web2_guest_id: u64,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn send_invitation_signless_no_wallet(
            &mut self,
            no_wallet_name_encoded: String,
            web2_user_id: u64,
            web2_guest_id: u64,
        ) -> impl Call<Output = Bet2ChessEvents, Args = Self::Args>;
        fn all_games(&self) -> impl Query<Output = Vec<(u64, GameData)>, Args = Self::Args>;
        fn game_data(
            &self,
            game_id: u64,
        ) -> impl Query<Output = Option<GameData>, Args = Self::Args>;
        fn games_id_ended(&self) -> impl Query<Output = Vec<u64>, Args = Self::Args>;
        fn games_id_started(&self) -> impl Query<Output = Vec<u64>, Args = Self::Args>;
        fn games_id_waiting(&self) -> impl Query<Output = Vec<u64>, Args = Self::Args>;
        fn invitation_bet(
            &self,
            first_web2_id: u64,
            second_web2_id: u64,
        ) -> impl Query<Output = Option<u128>, Args = Self::Args>;
        fn invitations_from_web_2_id(
            &self,
            web2_id: u64,
        ) -> impl Query<Output = Option<InvitationsState>, Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait QueryService {
        type Args;
        fn signless_account_data(
            &self,
            signless_address: ActorId,
        ) -> impl Query<Output = QueryEvent, Args = Self::Args>;
        fn signless_address_from_no_wallet_account(
            &self,
            no_wallet_account: String,
        ) -> impl Query<Output = QueryEvent, Args = Self::Args>;
        fn signless_address_from_user_address(
            &self,
            user_address: ActorId,
        ) -> impl Query<Output = QueryEvent, Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Signless {
        type Args;
        fn bind_signless_data_to_address(
            &mut self,
            user_address: ActorId,
            signless_data: SignlessAccount,
        ) -> impl Call<Output = SignlessEvent, Args = Self::Args>;
        fn bind_signless_data_to_no_wallet_account(
            &mut self,
            no_wallet_account: String,
            signless_data: SignlessAccount,
        ) -> impl Call<Output = SignlessEvent, Args = Self::Args>;
    }
}

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;

#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub Bet2Chess<A> {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl<A> traits::Bet2Chess for Bet2Chess<A> { type Args = A; fn accept_invitation (&mut self, web2_user_id: u64,web2_user_id_invitation_owner: u64,web2_match_game_id: u64,username_from_user_who_invite: String,own_username: String,) -> MockCall<A, Bet2ChessEvents>;fn accept_invitation_signless (&mut self, user_address: ActorId,web2_user_id: u64,web2_user_id_invitation_owner: u64,web2_match_game_id: u64,username_from_user_who_invite: String,own_username: String,) -> MockCall<A, Bet2ChessEvents>;fn accept_invitation_signless_no_wallet (&mut self, no_wallet_name_encoded: String,web2_user_id: u64,web2_user_id_invitation_owner: u64,web2_match_game_id: u64,username_from_user_who_invite: String,own_username: String,) -> MockCall<A, Bet2ChessEvents>;fn cancel_invitation (&mut self, first_web2_id: u64,second_web2_id: u64,) -> MockCall<A, Bet2ChessEvents>;fn cancel_invitation_signless (&mut self, user_address: ActorId,first_web2_id: u64,second_web2_id: u64,) -> MockCall<A, Bet2ChessEvents>;fn cancel_invitation_signless_no_wallet (&mut self, no_wallet_name_encoded: String,first_web2_id: u64,second_web2_id: u64,) -> MockCall<A, Bet2ChessEvents>;fn end_game_by_id (&mut self, game_id: u64,game_winner: Option<ActorId>,) -> MockCall<A, Bet2ChessEvents>;fn end_match (&mut self, game_id: u64,game_winner: Option<ActorId>,) -> MockCall<A, Bet2ChessEvents>;fn send_invitation (&mut self, web2_user_id: u64,web2_guest_id: u64,) -> MockCall<A, Bet2ChessEvents>;fn send_invitation_signless (&mut self, user_address: ActorId,web2_user_id: u64,web2_guest_id: u64,) -> MockCall<A, Bet2ChessEvents>;fn send_invitation_signless_no_wallet (&mut self, no_wallet_name_encoded: String,web2_user_id: u64,web2_guest_id: u64,) -> MockCall<A, Bet2ChessEvents>;fn all_games (& self, ) -> MockQuery<A, Vec<(u64,GameData,)>>;fn game_data (& self, game_id: u64,) -> MockQuery<A, Option<GameData>>;fn games_id_ended (& self, ) -> MockQuery<A, Vec<u64>>;fn games_id_started (& self, ) -> MockQuery<A, Vec<u64>>;fn games_id_waiting (& self, ) -> MockQuery<A, Vec<u64>>;fn invitation_bet (& self, first_web2_id: u64,second_web2_id: u64,) -> MockQuery<A, Option<u128>>;fn invitations_from_web_2_id (& self, web2_id: u64,) -> MockQuery<A, Option<InvitationsState>>; } }
    mock! { pub QueryService<A> {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl<A> traits::QueryService for QueryService<A> { type Args = A; fn signless_account_data (& self, signless_address: ActorId,) -> MockQuery<A, QueryEvent>;fn signless_address_from_no_wallet_account (& self, no_wallet_account: String,) -> MockQuery<A, QueryEvent>;fn signless_address_from_user_address (& self, user_address: ActorId,) -> MockQuery<A, QueryEvent>; } }
    mock! { pub Signless<A> {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl<A> traits::Signless for Signless<A> { type Args = A; fn bind_signless_data_to_address (&mut self, user_address: ActorId,signless_data: SignlessAccount,) -> MockCall<A, SignlessEvent>;fn bind_signless_data_to_no_wallet_account (&mut self, no_wallet_account: String,signless_data: SignlessAccount,) -> MockCall<A, SignlessEvent>; } }
}
